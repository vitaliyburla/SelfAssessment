## Multi-paradigm programming

-   Theory
    -   Procedural programming: ğŸ–ï¸ used
    -   Imperative programming: ğŸ‘‚ heard
    -   Structured programming: ğŸ‘‚ heard
    -   Non-structured programming: ğŸ‘‚ heard
    -   Functional programming: ğŸ–ï¸ used
    -   Prototype-based programming: ğŸ‘‚ heard
    -   Object-oriented programming: ğŸ–ï¸ used
    -   Object-based programming: ğŸ‘‚ heard
    -   Generic programming: ğŸ–ï¸ used
    -   Concurrent computing
    -   Asyncronous programming: ğŸ–ï¸ used
    -   Parallel programming: ğŸ“ known
    -   Reactive programming: ğŸ“ known
    -   FRP (Functional-reactive)
    -   Automata-based programming
    -   Domain-specific languages: ğŸ“ known
    -   Multi-paradigm programming
    -   Metaprogramming
    -   Actor model
-   OOP basics
    -   constructor: ğŸ–ï¸ used
    -   new: ğŸ–ï¸ used
    -   Static method: ğŸ–ï¸ used
    -   Method: ğŸ–ï¸ used
    -   Async method: ğŸ–ï¸ used
    -   Getters, Setters: ğŸ–ï¸ used
    -   Public fields: ğŸ–ï¸ used
    -   Private fields: ğŸ–ï¸ used
    -   Field declarations: ğŸ–ï¸ used
    -   Inheritance: ğŸ–ï¸ used
    -   Parent class: ğŸ–ï¸ used
    -   Polymorphism: ğŸ–ï¸ used
    -   Abstract class: ğŸ–ï¸ used
    -   Interface: ğŸ–ï¸ used
    -   Encapsulation: ğŸ–ï¸ used
    -   Hidden class: ğŸ–ï¸ used
    -   Object form: ğŸ–ï¸ used
    -   instance: ğŸ–ï¸ used
    -   Introspection
    -   Reflection
-   Patterns
    -   Singleton: ğŸ–ï¸ used
    -   Factory Method: ğŸ‘‚ heard
    -   Abstract Factory: ğŸ‘‚ heard
    -   Adapter: ğŸ‘‚ heard
    -   Observer: ğŸ–ï¸ used
    -   Strategy: ğŸ‘‚ heard
    -   Facade
    -   Proxy
    -   Chain of Responsibility: ğŸ‘‚ heard
    -   Command
    -   Iterator: ğŸ‘‚ heard
    -   State: ğŸ‘‚ heard
    -   Bridge: ğŸ‘‚ heard
    -   Builder: ğŸ‘‚ heard
    -   Prototype
    -   Composite: ğŸ‘‚ heard
    -   Decorator: ğŸ‘‚ heard
    -   Flyweight
    -   Mediator
    -   Memento
    -   Template Method
    -   Visitor: ğŸ‘‚ heard
